# Различия между многопоточностью, мультипроцессингом и кооперативной многозадачностью для вычислений CPU

При выполнении вычислительных задач, таких как сложение больших чисел, эффективность работы программы может значительно
различаться в зависимости от того, какой подход используется: **многопоточность**, **мультипроцессинг** или **кооперативная
многозадачность** (асинхронное программирование).

---

## 1. Многопоточность (Threading)

Многопоточность использует несколько потоков внутри одного процесса. Каждый поток разделяет память с другими потоками того же
процесса. Однако в Python многопоточность ограничена из-за **GIL (Global Interpreter Lock)**, который позволяет только одному
потоку выполнять код Python на CPU в каждый момент времени. Это значит, что многопоточность в Python полезна для задач
ввода/вывода, но не для интенсивных вычислений на CPU.

- **Плюсы:**
    - Простота использования для задач ввода/вывода.
    - Меньшая нагрузка на память, так как потоки разделяют пространство памяти.

- **Минусы:**
    - Ограничение производительности при вычислениях на CPU из-за GIL.
    - Потоки могут мешать друг другу, вызывая конкуренцию за ресурсы (например, переменные).

---

## 2. Мультипроцессинг (Multiprocessing)

Мультипроцессинг запускает несколько процессов, каждый из которых выполняется независимо. Каждый процесс имеет своё собственное
пространство памяти и не разделяет его с другими процессами. Мультипроцессинг обходит ограничение GIL, так как каждый процесс
получает собственную копию интерпретатора Python.

- **Плюсы:**
    - Подходит для вычислительно интенсивных задач, так как процессы работают параллельно и могут использовать несколько ядер
      процессора.
    - Меньше ограничений, связанных с GIL.

- **Минусы:**
    - Высокие накладные расходы на создание процессов и межпроцессовое взаимодействие.
    - Больше использования памяти, так как процессы не разделяют память.

---

## 3. Кооперативная многозадачность (Async/await)

Асинхронное программирование основано на кооперативной многозадачности, где задачи переключаются друг с другом вручную в момент
ожидания ввода/вывода. Оно не подходит для вычислительно интенсивных задач на CPU, так как асинхронность не предоставляет
реальной параллельности. Асинхронные программы полезны для операций с вводом/выводом, таких как работа с сетью или файлами.

- **Плюсы:**
    - Эффективно при обработке задач ввода/вывода.
    - Очень легкие и быстрые контекстные переключения.
    - Меньшие накладные расходы по сравнению с потоками и процессами.

- **Минусы:**
    - Не подходит для вычислительно интенсивных задач, так как все задачи выполняются последовательно на одном потоке.
    - Сложнее в реализации и отладке.

---

## Таблица сравнения для чисел 1,000,000 и 100,000,000

| Подход                            | Время выполнения (1,000,000) | Время выполнения (100,000,000) | Преимущества                                    | Недостатки                                             |
|-----------------------------------|------------------------------|--------------------------------|-------------------------------------------------|--------------------------------------------------------|
| **Многопоточность**               | Относительно медленное       | Очень медленное                | Хорошо для задач с вводом/выводом               | GIL ограничивает производительность на CPU             |
| **Мультипроцессинг**              | Быстрое                      | Быстрое                        | Полная параллелизация, задействование всех ядер | Высокие накладные расходы на создание процессов        |
| **Кооперативная многозадачность** | Медленное                    | Очень медленное                | Эффективно для ввода/вывода                     | Непригоден для задач, требующих интенсивных вычислений |

### Описание таблицы:

1. **Многопоточность** показывает плохие результаты на вычислительно интенсивных задачах из-за ограничения GIL. Для расчета
   суммы всех чисел от 1 до 1,000,000 выполнение может занимать больше времени, чем при использовании других подходов, особенно
   при увеличении объема данных.
2. **Мультипроцессинг** обеспечивает наилучшую производительность, так как каждое ядро процессора может независимо обрабатывать
   подзадачи. Этот подход показывает значительное улучшение времени выполнения как для небольших задач (1,000,000 чисел), так и
   для больших задач (100,000,000 чисел).
3. **Кооперативная многозадачность (Async)** не подходит для таких вычислений. Хотя она может выполнять задачи эффективно,
   переключаясь между ними, для задач, требующих вычислительной мощности, асинхронный подход будет медленным, поскольку
   выполняется на одном потоке.

---

## Заключение

- **Многопоточность** хорошо подходит для задач, где основное время уходит на ввод/вывод, но не является эффективной для
  вычислений на CPU.
- **Мультипроцессинг** — лучший выбор для вычислительно интенсивных задач, таких как сложение большого количества чисел, так
  как позволяет использовать все доступные ядра процессора.
- **Кооперативная многозадачность** эффективна для ввода/вывода, но не подходит для задач, требующих значительных вычислений.

Рекомендуется выбирать подход, исходя из характера задачи. Для вычислительных задач всегда предпочтителен мультипроцессинг, а
для операций с сетью и файловыми системами — асинхронное программирование.